# Руководство по созданию модулей

---

## Структура модуля

Каждый модуль должен быть bash-файлом и включать четыре обязательных блока:

1. Конфигурирование — переменные с префиксом модуля и значениями по умолчанию.
2. Импорт других модулей — директивы `@module`.
3. Тело модуля — логика, которая может быть выполнена сразу или через функции.
4. Тестирование — проверка результата работы модуля.

Пример:

```bash
set -Euo pipefail

@module logger.bash

# Конфигурирование
MY_MODULE_VAR="${MY_MODULE_VAR:-default_value}"

# Тело
logger::log "Installing something"
apt update || logger::err "apt update failed"

# Тестирование
if command -v something >/dev/null; then
    logger::log "Test passed"
else
    logger::err "Test failed"
fi
```

---

## Форматирование и стиль кода

### Отступы

Используем 4 пробела для всех уровней вложенности. Это повышает читаемость и унифицирует стиль в проекте.

### Блоковая запись в файл

Не используем `cat <<EOF`. Вместо этого:

```bash
{
    echo "String1"
    echo "String2"
} > /to/file
```

Это улучшает читаемость, позволяет легко использовать переменные и логгирование.

---

## Именование переменных и функций

### Переменные конфигурации

Префикс формируется по схеме:

```
<ИМЯ_МОДУЛЯ_ЗАГЛАВНЫМИ_С_ПОДЧЕРКИВАНИЕМ>_
```

Пример:

```bash
TOR_SETUP_SOCKS_HOST="${TOR_SETUP_SOCKS_HOST:-127.0.0.1}"
```

### Внутренние переменные

Если переменная используется только внутри модуля и не предназначена для внешнего использования — она должна начинаться с подчёркивания:

```bash
_ATTEMPTS=0
_RETRIES=0
```

### Функции

Формат:

```
<имя_модуля>::<имя_функции>
```

Пример:

```bash
logger::log() {
    echo "[*] $*"
}
```

---

## Комментарии

Комментарии в коде должны быть написаны на английском языке. Комментарий должен объяснять **зачем** используется тот или иной блок кода, а не описывать очевидное. Хороший комментарий отвечает на вопрос "почему", а не "что".

Пример:

```bash
# Retry Tor connection in case of slow startup or first boot
```

---

## Система модулей `@module`

Для подключения других модулей используем:

```bash
@module logger.bash
```

Сборщик подставит содержимое `logger.bash` вместо директивы. Вложенные зависимости подключаются рекурсивно, без повторов.

---

## Безопасность и ошибки

Все модули должны начинаться с:

```bash
set -Euo pipefail
```

* `-E` — улавливает ошибки в функциях.
* `-u` — запрещает использование необъявленных переменных.
* `-o pipefail` — ловит ошибки в пайпах.

---

## Логгирование

Для вывода логов:

```bash
logger::log "Normal message"
logger::err "Failure message"
```

* `logger::log` — обычные сообщения.
* `logger::err` — ошибки с завершением выполнения.

---

## Тестирование

Тестирование может включать:

* Прямую проверку.
* Многократные попытки.
* Перезапуск службы.

Пример:

```bash
_ATTEMPTS=0
_RESTARTS=0
while ! check_service; do
    ((_ATTEMPTS++))
    if (( _ATTEMPTS % 6 == 0 )); then
        ((_RESTARTS++))
        if (( _RESTARTS <= 1 )); then
            systemctl restart something
        else
            logger::err "Service failed to start"
        fi
    fi
    sleep 5
done
```

---

## Поведение при импорте

Модули могут выполнять код при подключении, если это ожидаемо. Однако при необходимости повторного использования, код следует упаковывать в функции:

```bash
setup::run() {
    logger::log "Setting up something"
    ...
}
```

Это позволяет вызывать поведение вручную и использовать модуль повторно.

---

## Документирование модулей

Каждый модуль должен быть описан в `README.md` в корне каталога `setup-modules/`.

### Правила оформления:

* Каждому модулю соответствует один раздел в `README.md`.
* Раздел должен содержать: назначение модуля, переменные конфигурации, экспортируемые функции и пример использования.
* Модули перечисляются в README **в алфавитном порядке по имени файла**.
