#!/bin/bash

@module logger.bash

REQUIRED_TOOLS="docker limbo-restore.bash"

# === Check for required tools  ===

missed_tools=()
for cmd in $REQUIRED_TOOLS; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        missed_tools+=("$cmd")
    fi
done

if ((${#missed_tools[@]})); then
    echo "Required tools not found:" >&2
    for cmd in "${missed_tools[@]}"; do
        echo "  - $cmd" >&2
    done
    echo "Hint: run dev-prod-init.recipe from debian-setup-factory" >&2
    echo "Abort"
    exit 127
fi

# Trap function to be used for deleting imported private key in case of failed/interrupted script
cleanup_gpg_secret() {
    if [[ -n "${GPG_PRIV_FINGERPRINT:-}" ]]; then
        echo "Deleting private key from keyring: $GPG_PRIV_FINGERPRINT"
        gpg --batch --yes --delete-secret-keys "$GPG_PRIV_FINGERPRINT" >/dev/null 2>&1 || true
    fi
}

# === Restore from backup (limbo-restore) ===

echo "Restore from backup:"
read -p "Do you want to restore the server from a backup now? (yes/no) [${RESTORE_FROM_BACKUP:-yes}]: " input
RESTORE_FROM_BACKUP=${input:-${RESTORE_FROM_BACKUP:-yes}}

if [[ "${RESTORE_FROM_BACKUP,,}" == "yes" ]]; then
    # ==== GPG (optional) ====
    RESTORE_CONFIG_FILE="/etc/limbo-backup/restore.conf.bash"
    GPG_ENABLED=0
    GPG_PRIV_FINGERPRINT=""
    GPG_PUB_FINGERPRINT=""

    read -p "Use GPG for restore/decryption? (yes/no) [${GPG_ENABLE:-yes}]: " input
    GPG_ENABLE=${input:-${GPG_ENABLE:-yes}}

    if [[ "${GPG_ENABLE,,}" == "yes" ]]; then
        # 1) Import PRIVATE key (temporary; will be removed after restore)
        while :; do
            read -p "Path to ASCII-armored PRIVATE key (.asc) for decryption: " GPG_PRIVKEY_PATH
            if [[ -f "$GPG_PRIVKEY_PATH" ]]; then
                GPG_PRIV_FINGERPRINT=$(gpg --with-colons --import-options show-only --import "$GPG_PRIVKEY_PATH" 2>/dev/null | awk -F: '/^fpr:/{print $10; exit}')
                if [[ -z "$GPG_PRIV_FINGERPRINT" ]]; then
                    echo "Could not read a fingerprint from the provided key. Please provide a valid ASCII-armored private key."
                else
                    echo "Importing private key into keyring (temporary)..."
                    gpg --batch --import "$GPG_PRIVKEY_PATH" || {
                        echo "Private key import failed"
                        break
                    }
                    echo "GPG private key imported. Fingerprint: $GPG_PRIV_FINGERPRINT"
                    # Arrange for private key cleanup after script ends or has been terminated (best-effort)
                    trap cleanup_gpg_secret SIGINT SIGTERM EXIT
                    break
                fi
            else
                echo "File not found: $GPG_PRIVKEY_PATH"
            fi
        done

        # 2) Import PUBLIC key (will remain in the system for future backup encryption)
        while :; do
            read -p "Path to ASCII-armored PUBLIC key (.asc) to keep in the system: " GPG_PUBKEY_PATH
            if [[ -f "$GPG_PUBKEY_PATH" ]]; then
                GPG_PUB_FINGERPRINT=$(gpg --with-colons --import-options show-only --import "$GPG_PUBKEY_PATH" 2>/dev/null | awk -F: '/^fpr:/{print $10; exit}')
                if [[ -z "$GPG_PUB_FINGERPRINT" ]]; then
                    echo "Could not read a fingerprint from the provided key. Please provide a valid ASCII-armored public key."
                else
                    echo "Importing public key into keyring..."
                    gpg --batch --import "$GPG_PUBKEY_PATH" || {
                        echo "Public key import failed"
                        break
                    }
                    GPG_ENABLED=1
                    echo "GPG public key imported. Fingerprint: $GPG_PUB_FINGERPRINT"
                    break
                fi
            else
                echo "File not found: $GPG_PUBKEY_PATH"
            fi
        done
    fi

    # ==== end GPG (optional) ====

    while :; do
        read -p "Enter backup URL or local path (supports http://, https://, file://, or a local path) [${BACKUP_SOURCE:-}]: " input
        BACKUP_SOURCE=${input:-${BACKUP_SOURCE:-}}

        if [[ -z "$BACKUP_SOURCE" ]]; then
            echo "Backup source cannot be empty."
            continue
        fi

        if [[ "$BACKUP_SOURCE" =~ ^https?:// ]]; then
            SOURCE_OK=1
        elif [[ "$BACKUP_SOURCE" =~ ^file:// ]]; then
            LOCAL_PATH="${BACKUP_SOURCE#file://}"
            if [[ -f "$LOCAL_PATH" ]]; then
                SOURCE_OK=1
            else
                echo "Local file from file:// not found: $LOCAL_PATH"
                SOURCE_OK=0
            fi
        else
            if [[ -f "$BACKUP_SOURCE" ]]; then
                if command -v readlink >/dev/null 2>&1; then
                    BACKUP_SOURCE="$(readlink -f "$BACKUP_SOURCE")"
                fi
                SOURCE_OK=1
            else
                echo "Local file not found: $BACKUP_SOURCE"
                SOURCE_OK=0
            fi
        fi

        [[ "${SOURCE_OK:-0}" -eq 1 ]] && break
    done

    echo ""
    echo "The following backup-tool configuration will be saved to ${RESTORE_CONFIG_FILE}:"
    echo "-----------------------------------------------------------------------"
    for line in "${RESTORE_CONFIG_LINES[@]}"; do
        echo "$line"
    done
    echo "-----------------------------------------------------------------------"
    echo ""

    echo ""
    echo "The restore script will be executed as:"
    echo "  limbo-restore.bash \"$BACKUP_SOURCE\""
    echo ""
    read -p "Proceed with restore? (y/n): " CONFIRM
    echo ""
    if [[ "$CONFIRM" != "y" ]]; then
        echo "Restore aborted by user."
        echo ""
    else
        # Existing variables will be set with new values or not touched if they are already set. New variables will be appended to the config file
        for line in "${RESTORE_CONFIG_LINES[@]}"; do
            key=${line%%=*}
            repl=${line//&/\\&}
            repl=${repl//|/\\|}
            line_slash_esc=${line//\//\\/}
            sed -i \
                -e "/^[[:space:]]*${line_slash_esc}\$/ { h; b; }" \
                -e "/^[[:space:]]*${key}=/ { s|.*|${repl}|; h; }" \
                -e '$ { x; /./ { x; b; }; x; a\'$'\n'''"$line"''$'\n'' }' \
                "$RESTORE_CONFIG_FILE"
        done
        echo "Configuration saved to $RESTORE_CONFIG_FILE"
        echo ""

        echo "Running limbo-restore.bash ${BACKUP_SOURCE}..."
        limbo-restore.bash "$BACKUP_SOURCE"
        RESTORE_RC=$?
        # (Added) Ensure private key is removed right after restore as well
        if [[ -n "${GPG_PRIV_FINGERPRINT:-}" ]]; then
            echo "Deleting private key from keyring: $GPG_PRIV_FINGERPRINT"
            gpg --batch --yes --delete-secret-keys "$GPG_PRIV_FINGERPRINT" || echo "Warning: failed to delete private key."
            GPG_PRIV_FINGERPRINT=""
        fi

        echo ""
        if [[ $RESTORE_RC -ne 0 ]]; then
            echo "Restore finished with errors (exit code $RESTORE_RC)."
        else
            echo "Restore completed successfully."
        fi
        echo ""
    fi
fi
