#!/bin/bash

@module logger.bash

REQUIRED_TOOLS="docker limbo-restore.bash"

# === Check for required tools  ===

missed_tools=()
for cmd in $REQUIRED_TOOLS; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        missed_tools+=("$cmd")
    fi
done

if ((${#missed_tools[@]})); then
    echo "Required tools not found:" >&2
    for cmd in "${missed_tools[@]}"; do
        echo "  - $cmd" >&2
    done
    echo "Hint: run dev-prod-init.recipe from debian-setup-factory" >&2
    echo "Abort"
    exit 127
fi

# Include other modules only after checking for required tools
@module bitwarden.bash

# Trap function to be used for deleting imported private key in case of failed/interrupted script
cleanup_gpg_secret() {
    if [[ -n "${GPG_PRIV_FINGERPRINT:-}" ]]; then
        echo "Deleting private key from keyring: $GPG_PRIV_FINGERPRINT"
        gpg --batch --yes --delete-secret-keys "$GPG_PRIV_FINGERPRINT" >/dev/null 2>&1 || true
    fi
}

# === Restore from backup (limbo-restore) ===

echo "Restore from backup:"
read -p "Do you want to restore the server from a backup now? (yes/no) [${RESTORE_FROM_BACKUP:-yes}]: " input
RESTORE_FROM_BACKUP=${input:-${RESTORE_FROM_BACKUP:-yes}}

if [[ "${RESTORE_FROM_BACKUP,,}" == "yes" ]]; then
    RESTORE_CONFIG_FILE="/etc/limbo-backup/restore.conf.bash"

    # ==== GPG (optional) ====
    read -p "Use GPG for restore/decryption? (yes/no) [${GPG_ENABLE:-yes}]: " input
    GPG_ENABLE=${input:-${GPG_ENABLE:-yes}}
    GPG_ENABLED=0
    GPG_PRIV_FINGERPRINT=""
    GPG_PUB_FINGERPRINT=""

    : "${BW_BACKUP_PRIVKEY_SECRET:=backup-privkey}"
    : "${BW_BACKUP_PUBKEY_SECRET:=backup-pubkey}"

    if [[ "${GPG_ENABLE,,}" == "yes" ]]; then
        echo "Fetching GPG keys from Bitwarden project: ${BWS_PROJECT_ID:-<unset>}"

        if ! BW_GPG_PRIV_ASCII="$(bitwarden::get_secret "$BW_BACKUP_PRIVKEY_SECRET" "${BWS_PROJECT_ID:-}")" || [[ -z "$BW_GPG_PRIV_ASCII" ]]; then
            echo "Bitwarden secret \"$BW_BACKUP_PRIVKEY_SECRET\" not found or empty"
            exit 1
        fi

        if ! GPG_PRIV_FINGERPRINT="$(
            printf '%s' "$BW_GPG_PRIV_ASCII" |
                gpg --batch --import-options show-only --with-colons --import 2>/dev/null |
                awk -F: '/^fpr:/{print $10; exit}'
        )" || [[ -z "$GPG_PRIV_FINGERPRINT" ]]; then
            echo "Unable to read private key fingerprint from Bitwarden secret \"$BW_BACKUP_PRIVKEY_SECRET\""
            exit 1
        fi

        printf '%s' "$BW_GPG_PRIV_ASCII" | gpg --batch --yes --import || {
            echo "Private key import failed"
            exit 1
        }
        trap cleanup_gpg_secret SIGINT SIGTERM EXIT
        echo "GPG private key imported. Fingerprint: $GPG_PRIV_FINGERPRINT"

        if BW_GPG_PUB_ASCII="$(bitwarden::get_secret "$BW_BACKUP_PUBKEY_SECRET" "${BWS_PROJECT_ID:-}")" && [[ -n "$BW_GPG_PUB_ASCII" ]]; then
            GPG_PUB_FINGERPRINT="$(
                printf '%s' "$BW_GPG_PUB_ASCII" |
                    gpg --batch --import-options show-only --with-colons --import 2>/dev/null |
                    awk -F: '/^fpr:/{print $10; exit}'
            )" || true

            printf '%s' "$BW_GPG_PUB_ASCII" | gpg --batch --yes --import || {
                echo "Public key import failed (continuing without public key)"
            }

            [[ -n "$GPG_PUB_FINGERPRINT" ]] && echo "GPG public key imported. Fingerprint: $GPG_PUB_FINGERPRINT"
        else
            echo "Bitwarden secret \"$BW_BACKUP_PUBKEY_SECRET\" not set; continuing without public key"
        fi

        GPG_ENABLED=1
    fi
    # ==== end GPG (optional) ====

    RESTORE_CONFIG_LINES=(
        "GPG_ENABLED=${GPG_ENABLED}"
    )

    while :; do
        read -p "Enter backup URL or local path (supports http://, https://, file://, or a local path) [${BACKUP_SOURCE:-}]: " input
        BACKUP_SOURCE=${input:-${BACKUP_SOURCE:-}}

        if [[ -z "$BACKUP_SOURCE" ]]; then
            echo "Backup source cannot be empty."
            continue
        fi

        if [[ "$BACKUP_SOURCE" =~ ^https?:// ]]; then
            SOURCE_OK=1
        elif [[ "$BACKUP_SOURCE" =~ ^file:// ]]; then
            LOCAL_PATH="${BACKUP_SOURCE#file://}"
            if [[ -f "$LOCAL_PATH" ]]; then
                SOURCE_OK=1
            else
                echo "Local file from file:// not found: $LOCAL_PATH"
                SOURCE_OK=0
            fi
        else
            if [[ -f "$BACKUP_SOURCE" ]]; then
                if command -v readlink >/dev/null 2>&1; then
                    BACKUP_SOURCE="$(readlink -f "$BACKUP_SOURCE")"
                fi
                SOURCE_OK=1
            else
                echo "Local file not found: $BACKUP_SOURCE"
                SOURCE_OK=0
            fi
        fi

        [[ "${SOURCE_OK:-0}" -eq 1 ]] && break
    done

    echo ""
    echo "The following backup-tool configuration will be saved to ${RESTORE_CONFIG_FILE}:"
    echo "-----------------------------------------------------------------------"
    for line in "${RESTORE_CONFIG_LINES[@]}"; do
        echo "$line"
    done
    echo "-----------------------------------------------------------------------"
    echo ""

    echo ""
    echo "The restore script will be executed as:"
    echo "  limbo-restore.bash \"$BACKUP_SOURCE\""
    echo ""
    read -p "Proceed with restore? (y/n): " CONFIRM
    echo ""
    if [[ "$CONFIRM" != "y" ]]; then
        echo "Restore aborted by user."
        echo ""
    else
        # Existing variables will be set with new values or not touched if they are already set. New variables will be appended to the config file
        for line in "${RESTORE_CONFIG_LINES[@]}"; do
            key=${line%%=*}
            repl=${line//&/\\&}
            repl=${repl//|/\\|}
            line_slash_esc=${line//\//\\/}
            sed -i \
                -e "/^[[:space:]]*${line_slash_esc}\$/ { h; b; }" \
                -e "/^[[:space:]]*${key}=/ { s|.*|${repl}|; h; }" \
                -e '$ { x; /./ { x; b; }; x; a\'$'\n'''"$line"''$'\n'' }' \
                "$RESTORE_CONFIG_FILE"
        done
        echo "Configuration saved to $RESTORE_CONFIG_FILE"
        echo ""

        echo "Running limbo-restore.bash ${BACKUP_SOURCE}..."
        limbo-restore.bash "$BACKUP_SOURCE"
        RESTORE_RC=$?
        # (Added) Ensure private key is removed right after restore as well
        if [[ -n "${GPG_PRIV_FINGERPRINT:-}" ]]; then
            echo "Deleting private key from keyring: $GPG_PRIV_FINGERPRINT"
            gpg --batch --yes --delete-secret-keys "$GPG_PRIV_FINGERPRINT" || echo "Warning: failed to delete private key."
            GPG_PRIV_FINGERPRINT=""
        fi

        echo ""
        if [[ $RESTORE_RC -ne 0 ]]; then
            echo "Restore finished with errors (exit code $RESTORE_RC)."
        else
            echo "Restore completed successfully."
        fi
        echo ""
    fi
fi
